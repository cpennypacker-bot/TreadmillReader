<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Assault Runner Connect</title>
    <style>
/* ==========================================================================
   Assault Runner Connect - Styles
   ========================================================================== */

/* CSS Variables */
:root {
    --bg-primary: #0d1117;
    --bg-secondary: #161b22;
    --bg-tertiary: #21262d;
    --bg-card: #1c2128;

    --text-primary: #f0f6fc;
    --text-secondary: #8b949e;
    --text-muted: #6e7681;

    --accent-primary: #58a6ff;
    --accent-success: #3fb950;
    --accent-warning: #d29922;
    --accent-danger: #f85149;
    --accent-record: #ff4757;

    --border-color: #30363d;
    --border-radius: 12px;
    --border-radius-sm: 8px;

    --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.3);
    --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.4);
    --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.5);

    --transition-fast: 150ms ease;
    --transition-normal: 250ms ease;
}

/* Reset & Base */
*, *::before, *::after {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

html {
    font-size: 16px;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    background-color: var(--bg-primary);
    color: var(--text-primary);
    line-height: 1.5;
    min-height: 100vh;
}

/* App Container */
.app-container {
    max-width: 900px;
    margin: 0 auto;
    padding: 20px;
}

/* Header */
.app-header {
    text-align: center;
    padding: 30px 0;
    border-bottom: 1px solid var(--border-color);
    margin-bottom: 30px;
}

.app-header h1 {
    font-size: 2.5rem;
    font-weight: 700;
    letter-spacing: -0.5px;
    background: linear-gradient(135deg, var(--accent-primary), var(--accent-success));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.app-header .subtitle {
    color: var(--text-secondary);
    font-size: 1rem;
    margin-top: 8px;
}

/* Section Titles */
.section-title {
    font-size: 1.1rem;
    font-weight: 600;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-bottom: 16px;
}

/* Buttons */
.btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    padding: 12px 24px;
    font-size: 1rem;
    font-weight: 600;
    border: none;
    border-radius: var(--border-radius-sm);
    cursor: pointer;
    transition: all var(--transition-fast);
    text-decoration: none;
}

.btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.btn-icon {
    width: 20px;
    height: 20px;
}

.btn-primary {
    background: linear-gradient(135deg, var(--accent-primary), #4493f8);
    color: white;
    box-shadow: var(--shadow-sm);
}

.btn-primary:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: var(--shadow-md);
}

.btn-secondary {
    background: var(--bg-tertiary);
    color: var(--text-primary);
    border: 1px solid var(--border-color);
}

.btn-secondary:hover:not(:disabled) {
    background: var(--bg-card);
    border-color: var(--text-muted);
}

.btn-record {
    background: linear-gradient(135deg, var(--accent-record), #ff6b7a);
    color: white;
}

.btn-record:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 4px 20px rgba(255, 71, 87, 0.4);
}

.btn-stop {
    background: var(--bg-tertiary);
    color: var(--accent-record);
    border: 2px solid var(--accent-record);
}

.btn-stop:hover:not(:disabled) {
    background: rgba(248, 81, 73, 0.1);
}

.btn-export {
    background: linear-gradient(135deg, var(--accent-success), #2ea043);
    color: white;
}

.btn-export:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 4px 20px rgba(63, 185, 80, 0.4);
}

.btn-small {
    padding: 6px 12px;
    font-size: 0.85rem;
}

/* Connection Panel */
.connection-panel {
    background: var(--bg-secondary);
    border-radius: var(--border-radius);
    padding: 24px;
    margin-bottom: 24px;
    border: 1px solid var(--border-color);
}

.connection-status {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 12px;
}

.status-indicator {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background: var(--text-muted);
    transition: all var(--transition-normal);
}

.status-indicator.connecting {
    background: var(--accent-warning);
    animation: pulse 1.5s ease-in-out infinite;
}

.status-indicator.connected {
    background: var(--accent-success);
    box-shadow: 0 0 12px var(--accent-success);
}

.status-text {
    font-weight: 600;
    font-size: 1.1rem;
}

.device-info {
    color: var(--text-secondary);
    margin-bottom: 20px;
}

.device-name {
    font-family: monospace;
    background: var(--bg-tertiary);
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 0.9rem;
}

.connection-buttons {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
}

/* Warning Banner */
.warning-banner {
    display: flex;
    align-items: center;
    gap: 12px;
    background: rgba(210, 153, 34, 0.15);
    border: 1px solid var(--accent-warning);
    border-radius: var(--border-radius-sm);
    padding: 16px;
    margin-bottom: 24px;
    color: var(--accent-warning);
}

.warning-icon {
    width: 24px;
    height: 24px;
    flex-shrink: 0;
}

/* Metrics Dashboard */
.metrics-dashboard {
    margin-bottom: 24px;
}

.metrics-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 16px;
}

.metric-card {
    background: var(--bg-secondary);
    border-radius: var(--border-radius);
    padding: 20px;
    border: 1px solid var(--border-color);
    text-align: center;
    transition: all var(--transition-fast);
}

.metric-card:hover {
    border-color: var(--text-muted);
    transform: translateY(-2px);
}

.metric-card.metric-primary {
    background: linear-gradient(135deg, var(--bg-secondary), var(--bg-card));
}

.metric-label {
    font-size: 0.85rem;
    font-weight: 600;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 8px;
}

.metric-value {
    font-size: 2.5rem;
    font-weight: 700;
    font-variant-numeric: tabular-nums;
    line-height: 1.2;
}

.metric-card.metric-secondary .metric-value {
    font-size: 2rem;
}

.metric-unit {
    font-size: 1rem;
    font-weight: 400;
    color: var(--text-secondary);
    margin-left: 4px;
}

/* Large Metrics Display (Top of Page) */
.metrics-grid-large {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 20px;
    margin-bottom: 30px;
}

.metric-card-large {
    background: linear-gradient(135deg, var(--bg-secondary), var(--bg-card));
    border-radius: var(--border-radius);
    padding: 28px 20px;
    border: 1px solid var(--border-color);
    text-align: center;
    transition: all var(--transition-fast);
}

.metric-card-large:hover {
    border-color: var(--accent-primary);
    transform: translateY(-3px);
    box-shadow: var(--shadow-md);
}

.metric-label-large {
    font-size: 1rem;
    font-weight: 600;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-bottom: 12px;
}

.metric-value-large {
    font-size: 4rem;
    font-weight: 700;
    font-variant-numeric: tabular-nums;
    line-height: 1.1;
    color: var(--text-primary);
}

.metric-unit-large {
    font-size: 1.2rem;
    font-weight: 400;
    color: var(--text-secondary);
    margin-left: 6px;
}

.metric-sublabel {
    font-size: 0.75rem;
    color: var(--text-muted);
    margin-top: 6px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

/* Recording Panel */
.recording-panel {
    background: var(--bg-secondary);
    border-radius: var(--border-radius);
    padding: 24px;
    margin-bottom: 24px;
    border: 1px solid var(--border-color);
}

.recording-controls {
    display: flex;
    flex-direction: column;
    gap: 16px;
}

.recording-status {
    display: flex;
    align-items: center;
    gap: 12px;
}

.recording-indicator {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: var(--text-muted);
    transition: all var(--transition-normal);
}

.recording-indicator.recording {
    background: var(--accent-record);
    animation: pulse-record 1s ease-in-out infinite;
}

.recording-text {
    font-weight: 600;
}

.recording-time {
    font-family: monospace;
    font-size: 1.2rem;
    color: var(--accent-record);
    margin-left: auto;
}

.recording-buttons {
    display: flex;
    gap: 12px;
}

/* Export Panel */
.export-panel {
    background: var(--bg-secondary);
    border-radius: var(--border-radius);
    padding: 24px;
    margin-bottom: 24px;
    border: 1px solid var(--accent-success);
}

.workout-summary {
    background: var(--bg-tertiary);
    border-radius: var(--border-radius-sm);
    padding: 16px;
    margin-bottom: 20px;
}

.summary-row {
    display: flex;
    justify-content: space-between;
    padding: 8px 0;
    border-bottom: 1px solid var(--border-color);
}

.summary-row:last-child {
    border-bottom: none;
}

.summary-label {
    color: var(--text-secondary);
}

.summary-value {
    font-weight: 600;
    font-variant-numeric: tabular-nums;
}

.export-buttons {
    display: flex;
    gap: 12px;
    margin-bottom: 16px;
    flex-wrap: wrap;
}

.export-hint {
    font-size: 0.9rem;
    color: var(--text-secondary);
}

.export-hint a {
    color: var(--accent-primary);
    text-decoration: none;
}

.export-hint a:hover {
    text-decoration: underline;
}

/* Data Log Panel */
.data-log-panel {
    background: var(--bg-secondary);
    border-radius: var(--border-radius);
    border: 1px solid var(--border-color);
    margin-bottom: 24px;
    overflow: hidden;
}

.collapse-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    padding: 16px 24px;
    background: transparent;
    border: none;
    color: var(--text-primary);
    cursor: pointer;
    transition: background var(--transition-fast);
}

.collapse-header:hover {
    background: var(--bg-tertiary);
}

.collapse-header .section-title {
    margin-bottom: 0;
}

.collapse-icon {
    width: 24px;
    height: 24px;
    color: var(--text-secondary);
    transition: transform var(--transition-normal);
}

.collapse-icon.expanded {
    transform: rotate(180deg);
}

.data-log-content {
    padding: 0 24px 24px;
}

.log-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
}

.log-count {
    color: var(--text-secondary);
    font-size: 0.9rem;
}

.log-entries {
    background: var(--bg-primary);
    border-radius: var(--border-radius-sm);
    padding: 16px;
    max-height: 300px;
    overflow-y: auto;
    font-family: monospace;
    font-size: 0.85rem;
}

.log-empty {
    color: var(--text-muted);
    text-align: center;
    padding: 20px;
}

.log-entry {
    padding: 4px 0;
    border-bottom: 1px solid var(--border-color);
    display: flex;
    gap: 16px;
}

.log-entry:last-child {
    border-bottom: none;
}

.log-timestamp {
    color: var(--text-muted);
    flex-shrink: 0;
}

.log-data {
    color: var(--text-secondary);
}

/* Footer */
.app-footer {
    text-align: center;
    padding: 24px;
    color: var(--text-muted);
    font-size: 0.9rem;
    border-top: 1px solid var(--border-color);
}

.footer-note {
    margin-top: 8px;
    font-size: 0.8rem;
}

/* Animations */
@keyframes pulse {
    0%, 100% {
        opacity: 1;
    }
    50% {
        opacity: 0.5;
    }
}

@keyframes pulse-record {
    0%, 100% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(255, 71, 87, 0.7);
    }
    50% {
        transform: scale(1.1);
        box-shadow: 0 0 0 10px rgba(255, 71, 87, 0);
    }
}

/* Scrollbar Styling */
::-webkit-scrollbar {
    width: 8px;
}

::-webkit-scrollbar-track {
    background: var(--bg-primary);
}

::-webkit-scrollbar-thumb {
    background: var(--bg-tertiary);
    border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
    background: var(--text-muted);
}

/* Responsive */
@media (max-width: 900px) {
    .metrics-grid-large {
        grid-template-columns: repeat(2, 1fr);
    }

    .metric-value-large {
        font-size: 3.2rem;
    }
}

@media (max-width: 600px) {
    .app-container {
        padding: 12px;
    }

    .app-header h1 {
        font-size: 1.8rem;
    }

    .metrics-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
    }

    .metrics-grid-large {
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
    }

    .metric-card-large {
        padding: 20px 16px;
    }

    .metric-value-large {
        font-size: 2.5rem;
    }

    .metric-unit-large {
        font-size: 1rem;
    }

    .metric-value {
        font-size: 2rem;
    }

    .metric-card.metric-secondary .metric-value {
        font-size: 1.5rem;
    }

    .connection-buttons,
    .recording-buttons,
    .export-buttons {
        flex-direction: column;
    }

    .btn {
        width: 100%;
    }
}
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <header class="app-header">
            <h1>Assault Runner Connect</h1>
        </header>

        <!-- Real-Time Metrics Dashboard -->
        <section class="metrics-dashboard" id="metricsDashboard">
            <div class="metrics-grid-large">
                <!-- Speed -->
                <div class="metric-card-large">
                    <div class="metric-label-large">Speed</div>
                    <div class="metric-value-large">
                        <span id="speedValue">0.0</span>
                        <span class="metric-unit-large">mph</span>
                    </div>
                </div>

                <!-- Pace -->
                <div class="metric-card-large">
                    <div class="metric-label-large">Pace</div>
                    <div class="metric-value-large">
                        <span id="paceValue">--:--</span>
                        <span class="metric-unit-large">min/mi</span>
                    </div>
                </div>

                <!-- Distance -->
                <div class="metric-card-large">
                    <div class="metric-label-large">Distance</div>
                    <div class="metric-value-large">
                        <span id="distanceValue">0.00</span>
                        <span class="metric-unit-large">mi</span>
                    </div>
                </div>

                <!-- Time -->
                <div class="metric-card-large">
                    <div class="metric-label-large">Time</div>
                    <div class="metric-value-large">
                        <span id="timeValue">00:00</span>
                    </div>
                </div>

                <!-- Heart Rate -->
                <div class="metric-card-large">
                    <div class="metric-label-large">Heart Rate</div>
                    <div class="metric-value-large">
                        <span id="heartRateValue">--</span>
                        <span class="metric-unit-large">bpm</span>
                    </div>
                </div>

                <!-- Recent Pace (30 sec avg) -->
                <div class="metric-card-large">
                    <div class="metric-label-large">Recent Pace</div>
                    <div class="metric-value-large">
                        <span id="recentPaceValue">--:--</span>
                        <span class="metric-unit-large">min/mi</span>
                    </div>
                    <div class="metric-sublabel">30 sec avg</div>
                </div>
            </div>
        </section>

        <!-- Connection Panel -->
        <section class="connection-panel">
            <div class="connection-status">
                <span class="status-indicator" id="statusIndicator"></span>
                <span class="status-text" id="statusText">Disconnected</span>
            </div>
            <div class="device-info" id="deviceInfo">
                <span class="device-name" id="deviceName">No device connected</span>
            </div>
            <div class="connection-buttons">
                <button class="btn btn-primary" id="connectBtn">
                    <svg class="btn-icon" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M14.24 12.01l2.32 2.32c.28-.72.44-1.51.44-2.33 0-.82-.16-1.59-.43-2.31l-2.33 2.32zm5.29-5.3l-1.26 1.26c.63 1.21.98 2.57.98 4.02s-.36 2.82-.98 4.02l1.2 1.2c.97-1.54 1.54-3.36 1.54-5.31-.01-1.89-.55-3.67-1.48-5.19zm-3.82 1L10 2H9v7.59L4.41 5 3 6.41 8.59 12 3 17.59 4.41 19 9 14.41V22h1l5.71-5.71-4.3-4.29 4.3-4.29zM11 5.83l1.88 1.88L11 9.59V5.83zm1.88 10.46L11 18.17v-3.76l1.88 1.88z"/>
                    </svg>
                    Connect to Assault Runner
                </button>
                <button class="btn btn-secondary" id="disconnectBtn" disabled>
                    Disconnect
                </button>
            </div>
        </section>

        <!-- Browser Compatibility Warning -->
        <div class="warning-banner" id="compatibilityWarning" style="display: none;">
            <svg class="warning-icon" viewBox="0 0 24 24" fill="currentColor">
                <path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/>
            </svg>
            <span>Web Bluetooth is not supported in this browser. Please use Chrome, Edge, or Opera.</span>
        </div>

        <!-- Hidden elements for data still tracked for export -->
        <span id="caloriesValue" style="display:none;">0</span>
        <span id="powerValue" style="display:none;">--</span>
        <span id="avgSpeedValue" style="display:none;">0.0</span>

        <!-- Recording Controls -->
        <section class="recording-panel">
            <h2 class="section-title">Recording</h2>
            <div class="recording-controls">
                <div class="recording-status">
                    <span class="recording-indicator" id="recordingIndicator"></span>
                    <span class="recording-text" id="recordingText">Not Recording</span>
                    <span class="recording-time" id="recordingTime"></span>
                </div>
                <div class="recording-buttons">
                    <button class="btn btn-record" id="startRecordingBtn" disabled>
                        <svg class="btn-icon" viewBox="0 0 24 24" fill="currentColor">
                            <circle cx="12" cy="12" r="8"/>
                        </svg>
                        Start Recording
                    </button>
                    <button class="btn btn-stop" id="stopRecordingBtn" disabled style="display: none;">
                        <svg class="btn-icon" viewBox="0 0 24 24" fill="currentColor">
                            <rect x="6" y="6" width="12" height="12"/>
                        </svg>
                        Stop Recording
                    </button>
                </div>
            </div>
        </section>

        <!-- Export Panel -->
        <section class="export-panel" id="exportPanel" style="display: none;">
            <h2 class="section-title">Export Workout</h2>
            <div class="workout-summary" id="workoutSummary">
                <div class="summary-row">
                    <span class="summary-label">Duration:</span>
                    <span class="summary-value" id="summaryDuration">--:--</span>
                </div>
                <div class="summary-row">
                    <span class="summary-label">Distance:</span>
                    <span class="summary-value" id="summaryDistance">0.00 mi</span>
                </div>
                <div class="summary-row">
                    <span class="summary-label">Avg Pace:</span>
                    <span class="summary-value" id="summaryPace">--:-- min/mi</span>
                </div>
                <div class="summary-row">
                    <span class="summary-label">Calories:</span>
                    <span class="summary-value" id="summaryCalories">0 kcal</span>
                </div>
                <div class="summary-row">
                    <span class="summary-label">Data Points:</span>
                    <span class="summary-value" id="summaryDataPoints">0</span>
                </div>
            </div>
            <div class="export-buttons">
                <button class="btn btn-export" id="downloadTcxBtn">
                    <svg class="btn-icon" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
                    </svg>
                    Download TCX for Garmin
                </button>
                <button class="btn btn-secondary" id="clearDataBtn">
                    Clear Data
                </button>
            </div>
            <p class="export-hint">
                Import the TCX file to Garmin Connect at
                <a href="https://connect.garmin.com/modern/import-data" target="_blank" rel="noopener">
                    connect.garmin.com/modern/import-data
                </a>
            </p>
        </section>

        <!-- Data Log (collapsible) -->
        <section class="data-log-panel">
            <button class="collapse-header" id="dataLogToggle">
                <h2 class="section-title">Data Log</h2>
                <svg class="collapse-icon" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/>
                </svg>
            </button>
            <div class="data-log-content" id="dataLogContent" style="display: none;">
                <div class="log-controls">
                    <span class="log-count" id="logCount">0 entries</span>
                    <button class="btn btn-small" id="clearLogBtn">Clear Log</button>
                </div>
                <div class="log-entries" id="logEntries">
                    <p class="log-empty">No data recorded yet. Connect to your Assault Runner and start recording.</p>
                </div>
            </div>
        </section>

        <!-- Footer -->
        <footer class="app-footer">
            <p>Assault Runner Connect - Web Bluetooth FTMS Client</p>
            <p class="footer-note">Requires Chrome, Edge, or Opera browser with Bluetooth enabled</p>
        </footer>
    </div>

    <script>
/**
 * Assault Runner Connect - Bluetooth Module
 */
const BluetoothManager = (function() {
    const FTMS_SERVICE_UUID = 0x1826;
    const TREADMILL_DATA_UUID = 0x2ACD;
    const HEART_RATE_SERVICE_UUID = 0x180D;
    const HEART_RATE_MEASUREMENT_UUID = 0x2A37;

    let device = null;
    let server = null;
    let treadmillDataCharacteristic = null;
    let heartRateCharacteristic = null;
    let isConnected = false;

    let onDataCallback = null;
    let onConnectionChangeCallback = null;
    let onErrorCallback = null;

    function isSupported() {
        return navigator.bluetooth !== undefined;
    }

    async function connect() {
        if (!isSupported()) {
            throw new Error('Web Bluetooth is not supported in this browser');
        }

        try {
            device = await navigator.bluetooth.requestDevice({
    acceptAllDevices: true,
    optionalServices: [
                    FTMS_SERVICE_UUID,
                    HEART_RATE_SERVICE_UUID,
                    'battery_service'
                ]
            });

            console.log('Device selected:', device.name);
            device.addEventListener('gattserverdisconnected', handleDisconnection);

            notifyConnectionChange('connecting');
            server = await device.gatt.connect();
            console.log('Connected to GATT server');

            const ftmsService = await server.getPrimaryService(FTMS_SERVICE_UUID);
            console.log('FTMS service obtained');

            try {
                treadmillDataCharacteristic = await ftmsService.getCharacteristic(TREADMILL_DATA_UUID);
                console.log('Treadmill Data characteristic obtained');
                await treadmillDataCharacteristic.startNotifications();
                treadmillDataCharacteristic.addEventListener('characteristicvaluechanged', handleTreadmillData);
                console.log('Subscribed to Treadmill Data notifications');
            } catch (err) {
                console.warn('Treadmill Data characteristic not available:', err.message);
            }

            try {
                const hrService = await server.getPrimaryService(HEART_RATE_SERVICE_UUID);
                heartRateCharacteristic = await hrService.getCharacteristic(HEART_RATE_MEASUREMENT_UUID);
                await heartRateCharacteristic.startNotifications();
                heartRateCharacteristic.addEventListener('characteristicvaluechanged', handleHeartRateData);
                console.log('Heart Rate monitoring enabled');
            } catch (err) {
                console.log('Heart Rate service not available (optional)');
            }

            isConnected = true;
            notifyConnectionChange('connected', device.name);

            return { success: true, deviceName: device.name };

        } catch (error) {
            console.error('Connection failed:', error);
            isConnected = false;
            notifyConnectionChange('disconnected');

            if (error.name === 'NotFoundError') {
                throw new Error('No compatible device found. Make sure your Assault Runner is powered on and in range.');
            } else if (error.name === 'SecurityError') {
                throw new Error('Bluetooth permission denied. Please allow Bluetooth access.');
            } else {
                throw error;
            }
        }
    }

    async function disconnect() {
        if (device && device.gatt.connected) {
            if (treadmillDataCharacteristic) {
                try {
                    await treadmillDataCharacteristic.stopNotifications();
                    treadmillDataCharacteristic.removeEventListener('characteristicvaluechanged', handleTreadmillData);
                } catch (e) { console.warn('Error stopping treadmill notifications:', e); }
            }
            if (heartRateCharacteristic) {
                try {
                    await heartRateCharacteristic.stopNotifications();
                    heartRateCharacteristic.removeEventListener('characteristicvaluechanged', handleHeartRateData);
                } catch (e) { console.warn('Error stopping HR notifications:', e); }
            }
            device.gatt.disconnect();
        }
        cleanup();
    }

    function handleDisconnection(event) {
        console.log('Device disconnected:', event.target.name);
        cleanup();
        notifyConnectionChange('disconnected');
        if (onErrorCallback) {
            onErrorCallback(new Error('Device disconnected unexpectedly'));
        }
    }

    function cleanup() {
        isConnected = false;
        treadmillDataCharacteristic = null;
        heartRateCharacteristic = null;
        server = null;
    }

    function handleTreadmillData(event) {
        const value = event.target.value;
        const data = parseTreadmillData(value);
        if (onDataCallback && data) {
            onDataCallback(data);
        }
    }

    function parseTreadmillData(dataView) {
        if (!dataView || dataView.byteLength < 2) return null;

        const flags = dataView.getUint16(0, true);
        let offset = 2;
        const data = { timestamp: Date.now(), flags: flags };

        if (offset + 2 <= dataView.byteLength) {
            data.instantaneousSpeed = dataView.getUint16(offset, true) * 0.01;
            offset += 2;
        }

        if ((flags & (1 << 1)) && offset + 2 <= dataView.byteLength) {
            data.averageSpeed = dataView.getUint16(offset, true) * 0.01;
            offset += 2;
        }

        if ((flags & (1 << 2)) && offset + 3 <= dataView.byteLength) {
            data.totalDistance = dataView.getUint8(offset) | (dataView.getUint8(offset + 1) << 8) | (dataView.getUint8(offset + 2) << 16);
            offset += 3;
        }

        if ((flags & (1 << 3)) && offset + 4 <= dataView.byteLength) {
            data.inclination = dataView.getInt16(offset, true) * 0.1;
            offset += 2;
            data.rampAngle = dataView.getInt16(offset, true) * 0.1;
            offset += 2;
        }

        if ((flags & (1 << 4)) && offset + 4 <= dataView.byteLength) {
            data.positiveElevationGain = dataView.getUint16(offset, true) * 0.1;
            offset += 2;
            data.negativeElevationGain = dataView.getUint16(offset, true) * 0.1;
            offset += 2;
        }

        if ((flags & (1 << 5)) && offset + 1 <= dataView.byteLength) {
            data.instantaneousPace = dataView.getUint8(offset) * 0.1;
            offset += 1;
        }

        if ((flags & (1 << 6)) && offset + 1 <= dataView.byteLength) {
            data.averagePace = dataView.getUint8(offset) * 0.1;
            offset += 1;
        }

        if ((flags & (1 << 7)) && offset + 5 <= dataView.byteLength) {
            data.totalEnergy = dataView.getUint16(offset, true);
            offset += 2;
            data.energyPerHour = dataView.getUint16(offset, true);
            offset += 2;
            data.energyPerMinute = dataView.getUint8(offset);
            offset += 1;
        }

        if ((flags & (1 << 8)) && offset + 1 <= dataView.byteLength) {
            data.heartRate = dataView.getUint8(offset);
            offset += 1;
        }

        if ((flags & (1 << 9)) && offset + 1 <= dataView.byteLength) {
            data.metabolicEquivalent = dataView.getUint8(offset) * 0.1;
            offset += 1;
        }

        if ((flags & (1 << 10)) && offset + 2 <= dataView.byteLength) {
            data.elapsedTime = dataView.getUint16(offset, true);
            offset += 2;
        }

        if ((flags & (1 << 11)) && offset + 2 <= dataView.byteLength) {
            data.remainingTime = dataView.getUint16(offset, true);
            offset += 2;
        }

        if ((flags & (1 << 12)) && offset + 4 <= dataView.byteLength) {
            data.forceOnBelt = dataView.getInt16(offset, true);
            offset += 2;
            data.powerOutput = dataView.getInt16(offset, true);
            offset += 2;
        }

        return data;
    }

    function handleHeartRateData(event) {
        const value = event.target.value;
        const flags = value.getUint8(0);
        let heartRate = (flags & 0x01) ? value.getUint16(1, true) : value.getUint8(1);
        if (onDataCallback) {
            onDataCallback({ timestamp: Date.now(), heartRate: heartRate, source: 'heart_rate_service' });
        }
    }

    function notifyConnectionChange(state, deviceName = null) {
        if (onConnectionChangeCallback) {
            onConnectionChangeCallback({ state: state, deviceName: deviceName, timestamp: Date.now() });
        }
    }

    function setDataCallback(callback) { onDataCallback = callback; }
    function setConnectionChangeCallback(callback) { onConnectionChangeCallback = callback; }
    function setErrorCallback(callback) { onErrorCallback = callback; }
    function getConnectionStatus() { return { isConnected: isConnected, deviceName: device ? device.name : null }; }

    return { isSupported, connect, disconnect, setDataCallback, setConnectionChangeCallback, setErrorCallback, getConnectionStatus };
})();

/**
 * Assault Runner Connect - Metrics Module (Imperial Units)
 */
const MetricsManager = (function() {
    const KMH_TO_MPH = 0.621371;
    const METERS_TO_MILES = 0.000621371;

    let currentMetrics = {
        instantaneousSpeed: 0, averageSpeed: 0, pace: null, averagePace: null,
        recentPace: null, totalDistance: 0, elapsedTime: 0, totalEnergy: 0,
        heartRate: null, powerOutput: null, inclination: null, cadence: null
    };

    let isRecording = false;
    let recordedData = [];
    let recordingStartTime = null;
    let workoutStartTimestamp = null;

    const smoothingBuffer = { speed: [], heartRate: [], power: [] };
    const SMOOTHING_WINDOW = 3;

    // Rolling 30-second window for recent pace calculation
    const recentSpeedBuffer = [];
    const RECENT_PACE_WINDOW_MS = 30000; // 30 seconds

    let onMetricsUpdateCallback = null;
    let onRecordingDataCallback = null;

    function processData(data) {
        if (!data) return;

        if (data.instantaneousSpeed !== undefined) {
            currentMetrics.instantaneousSpeed = smoothValue('speed', data.instantaneousSpeed);
            currentMetrics.pace = speedToPaceImperial(currentMetrics.instantaneousSpeed);

            // Update 30-second rolling average for recent pace
            const now = Date.now();
            recentSpeedBuffer.push({ timestamp: now, speed: data.instantaneousSpeed });
            // Remove entries older than 30 seconds
            while (recentSpeedBuffer.length > 0 && (now - recentSpeedBuffer[0].timestamp) > RECENT_PACE_WINDOW_MS) {
                recentSpeedBuffer.shift();
            }
            // Calculate average speed over last 30 seconds
            if (recentSpeedBuffer.length > 0) {
                const avgRecentSpeed = recentSpeedBuffer.reduce((sum, entry) => sum + entry.speed, 0) / recentSpeedBuffer.length;
                currentMetrics.recentPace = speedToPaceImperial(avgRecentSpeed);
            }
        }
        if (data.averageSpeed !== undefined) {
            currentMetrics.averageSpeed = data.averageSpeed;
            currentMetrics.averagePace = speedToPaceImperial(data.averageSpeed);
        }
        if (data.totalDistance !== undefined) currentMetrics.totalDistance = data.totalDistance;
        if (data.elapsedTime !== undefined) currentMetrics.elapsedTime = data.elapsedTime;
        if (data.totalEnergy !== undefined) currentMetrics.totalEnergy = data.totalEnergy;
        if (data.heartRate !== undefined && data.heartRate > 0) currentMetrics.heartRate = smoothValue('heartRate', data.heartRate);
        if (data.powerOutput !== undefined) currentMetrics.powerOutput = smoothValue('power', data.powerOutput);
        if (data.inclination !== undefined) currentMetrics.inclination = data.inclination;

        if (currentMetrics.instantaneousSpeed > 0) {
            currentMetrics.cadence = Math.round(100 + (currentMetrics.instantaneousSpeed * 8));
            currentMetrics.cadence = Math.min(200, Math.max(100, currentMetrics.cadence));
        } else {
            currentMetrics.cadence = null;
        }

        if (isRecording) recordDataPoint(data);
        if (onMetricsUpdateCallback) onMetricsUpdateCallback(getCurrentMetrics());
    }

    function smoothValue(type, value) {
        const buffer = smoothingBuffer[type];
        buffer.push(value);
        if (buffer.length > SMOOTHING_WINDOW) buffer.shift();
        return buffer.reduce((a, b) => a + b, 0) / buffer.length;
    }

    function speedToPaceImperial(speedKmh) {
        if (!speedKmh || speedKmh <= 0) return null;
        return 60 / (speedKmh * KMH_TO_MPH);
    }

    function kmhToMph(speedKmh) { return speedKmh * KMH_TO_MPH; }
    function metersToMiles(meters) { return meters * METERS_TO_MILES; }

    function formatPace(paceMinPerMile) {
        if (!paceMinPerMile || paceMinPerMile > 30) return '--:--';
        const minutes = Math.floor(paceMinPerMile);
        const seconds = Math.round((paceMinPerMile - minutes) * 60);
        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    function formatTime(seconds) {
        if (!seconds || seconds < 0) return '00:00';
        const hrs = Math.floor(seconds / 3600);
        const mins = Math.floor((seconds % 3600) / 60);
        const secs = Math.floor(seconds % 60);
        if (hrs > 0) return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    function formatDistance(meters) { return metersToMiles(meters).toFixed(2); }

    function getCurrentMetrics() {
        return {
            speed: kmhToMph(currentMetrics.instantaneousSpeed).toFixed(1),
            avgSpeed: kmhToMph(currentMetrics.averageSpeed).toFixed(1),
            pace: formatPace(currentMetrics.pace),
            avgPace: formatPace(currentMetrics.averagePace),
            recentPace: formatPace(currentMetrics.recentPace),
            distance: formatDistance(currentMetrics.totalDistance),
            distanceMeters: currentMetrics.totalDistance,
            distanceMiles: metersToMiles(currentMetrics.totalDistance),
            time: formatTime(currentMetrics.elapsedTime),
            timeSeconds: currentMetrics.elapsedTime,
            calories: Math.round(currentMetrics.totalEnergy),
            heartRate: currentMetrics.heartRate ? Math.round(currentMetrics.heartRate) : null,
            power: currentMetrics.powerOutput ? Math.round(currentMetrics.powerOutput) : null,
            cadence: currentMetrics.cadence,
            inclination: currentMetrics.inclination,
            raw: { ...currentMetrics }
        };
    }

    function startRecording() {
        isRecording = true;
        recordedData = [];
        recordingStartTime = Date.now();
        workoutStartTimestamp = new Date();
        recordDataPoint({ timestamp: recordingStartTime, isStart: true });
        console.log('Recording started');
    }

    function stopRecording() {
        isRecording = false;
        if (recordedData.length > 0) recordDataPoint({ timestamp: Date.now(), isEnd: true });
        console.log('Recording stopped. Data points:', recordedData.length);
        return getRecordedWorkout();
    }

    function recordDataPoint(data) {
        const timestamp = data.timestamp || Date.now();
        const elapsedMs = timestamp - recordingStartTime;
        const dataPoint = {
            timestamp, elapsedMs, elapsedSeconds: Math.floor(elapsedMs / 1000),
            speed: currentMetrics.instantaneousSpeed,
            speedMph: kmhToMph(currentMetrics.instantaneousSpeed),
            distance: currentMetrics.totalDistance,
            distanceMiles: metersToMiles(currentMetrics.totalDistance),
            calories: currentMetrics.totalEnergy,
            heartRate: currentMetrics.heartRate,
            cadence: currentMetrics.cadence,
            power: currentMetrics.powerOutput,
            pace: currentMetrics.pace
        };
        recordedData.push(dataPoint);
        if (onRecordingDataCallback) onRecordingDataCallback(dataPoint);
    }

    function getRecordedWorkout() {
        if (recordedData.length === 0) return null;

        const firstPoint = recordedData[0];
        const lastPoint = recordedData[recordedData.length - 1];
        const durationSeconds = (lastPoint.elapsedMs - firstPoint.elapsedMs) / 1000;
        const totalDistanceMeters = lastPoint.distance - (firstPoint.distance || 0);
        const totalCalories = lastPoint.calories - (firstPoint.calories || 0);

        let avgSpeedKmh = 0, avgHeartRate = 0, hrCount = 0, avgPower = 0, powerCount = 0;
        recordedData.forEach(point => {
            if (point.speed) avgSpeedKmh += point.speed;
            if (point.heartRate) { avgHeartRate += point.heartRate; hrCount++; }
            if (point.power) { avgPower += point.power; powerCount++; }
        });
        avgSpeedKmh = recordedData.length > 0 ? avgSpeedKmh / recordedData.length : 0;
        avgHeartRate = hrCount > 0 ? avgHeartRate / hrCount : null;
        avgPower = powerCount > 0 ? avgPower / powerCount : null;

        return {
            startTime: workoutStartTimestamp,
            durationSeconds, durationFormatted: formatTime(durationSeconds),
            distanceMeters: totalDistanceMeters, avgSpeedKmh,
            distanceMiles: metersToMiles(totalDistanceMeters).toFixed(2),
            avgSpeed: kmhToMph(avgSpeedKmh).toFixed(1),
            avgPace: formatPace(speedToPaceImperial(avgSpeedKmh)),
            avgPaceMinPerMile: speedToPaceImperial(avgSpeedKmh),
            calories: Math.round(totalCalories),
            avgHeartRate: avgHeartRate ? Math.round(avgHeartRate) : null,
            avgPower: avgPower ? Math.round(avgPower) : null,
            dataPoints: recordedData.length,
            trackpoints: recordedData
        };
    }

    function getRecordingStatus() {
        return {
            isRecording, startTime: recordingStartTime, dataPoints: recordedData.length,
            duration: isRecording && recordingStartTime ? Math.floor((Date.now() - recordingStartTime) / 1000) : 0
        };
    }

    function clearRecordedData() { recordedData = []; recordingStartTime = null; workoutStartTimestamp = null; isRecording = false; }

    function resetMetrics() {
        currentMetrics = { instantaneousSpeed: 0, averageSpeed: 0, pace: null, averagePace: null, recentPace: null, totalDistance: 0, elapsedTime: 0, totalEnergy: 0, heartRate: null, powerOutput: null, inclination: null, cadence: null };
        smoothingBuffer.speed = []; smoothingBuffer.heartRate = []; smoothingBuffer.power = [];
        recentSpeedBuffer.length = 0; // Clear the 30-second rolling buffer
    }

    function setMetricsUpdateCallback(callback) { onMetricsUpdateCallback = callback; }
    function setRecordingDataCallback(callback) { onRecordingDataCallback = callback; }

    return { processData, getCurrentMetrics, startRecording, stopRecording, getRecordedWorkout, getRecordingStatus, clearRecordedData, resetMetrics, setMetricsUpdateCallback, setRecordingDataCallback, formatPace, formatTime, formatDistance, speedToPaceImperial, kmhToMph, metersToMiles };
})();

/**
 * Assault Runner Connect - Export Module (TCX)
 * Garmin-compatible TCX format with proper element ordering
 */
const ExportManager = (function() {
    const TCX_NS = 'http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2';
    const ACT_EXT_NS = 'http://www.garmin.com/xmlschemas/ActivityExtension/v2';

    function formatISOTime(date) {
        // Ensure proper ISO 8601 format with Z suffix for UTC
        return date.toISOString();
    }

    function generateTCX(workout) {
        if (!workout || !workout.trackpoints || workout.trackpoints.length === 0) {
            throw new Error('No workout data to export');
        }

        const startTime = formatISOTime(workout.startTime);
        const calories = Math.max(0, Math.round(workout.calories || 0));
        const distance = Math.max(0, workout.distanceMeters || 0);
        const duration = Math.max(0, workout.durationSeconds || 0);

        let tcx = `<?xml version="1.0" encoding="UTF-8"?>
<TrainingCenterDatabase
  xmlns="${TCX_NS}"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:ns3="${ACT_EXT_NS}"
  xsi:schemaLocation="${TCX_NS} http://www.garmin.com/xmlschemas/TrainingCenterDatabasev2.xsd">
  <Activities>
    <Activity Sport="Running">
      <Id>${startTime}</Id>
      <Lap StartTime="${startTime}">
        <TotalTimeSeconds>${duration.toFixed(1)}</TotalTimeSeconds>
        <DistanceMeters>${distance.toFixed(1)}</DistanceMeters>
        <Calories>${calories}</Calories>
        <Intensity>Active</Intensity>
        <TriggerMethod>Manual</TriggerMethod>
        <Track>
${generateTrackpoints(workout)}
        </Track>
      </Lap>
    </Activity>
  </Activities>
</TrainingCenterDatabase>`;
        return tcx;
    }

    function generateTrackpoints(workout) {
        const trackpoints = workout.trackpoints;
        let xml = '';

        // Sample at most 1 point per second, max 3600 points
        const maxPoints = Math.min(trackpoints.length, 3600);
        const skipFactor = Math.max(1, Math.floor(trackpoints.length / maxPoints));

        for (let i = 0; i < trackpoints.length; i += skipFactor) {
            const tp = trackpoints[i];
            const pointTime = new Date(workout.startTime.getTime() + (tp.elapsedMs || 0));
            const distance = tp.distance || 0;

            xml += `          <Trackpoint>\n`;
            xml += `            <Time>${formatISOTime(pointTime)}</Time>\n`;
            xml += `            <DistanceMeters>${distance.toFixed(1)}</DistanceMeters>\n`;

            // Heart rate (must come before Cadence per TCX schema)
            if (tp.heartRate && tp.heartRate > 0) {
                xml += `            <HeartRateBpm>\n`;
                xml += `              <Value>${Math.round(tp.heartRate)}</Value>\n`;
                xml += `            </HeartRateBpm>\n`;
            }

            // Cadence (half value for running - Garmin convention)
            if (tp.cadence && tp.cadence > 0) {
                xml += `            <Cadence>${Math.round(tp.cadence / 2)}</Cadence>\n`;
            }

            // Extensions for speed and power
            if ((tp.speed && tp.speed > 0) || (tp.power && tp.power > 0) || (tp.cadence && tp.cadence > 0)) {
                xml += `            <Extensions>\n`;
                xml += `              <ns3:TPX>\n`;
                if (tp.speed && tp.speed > 0) {
                    const speedMs = tp.speed / 3.6; // km/h to m/s
                    xml += `                <ns3:Speed>${speedMs.toFixed(4)}</ns3:Speed>\n`;
                }
                if (tp.cadence && tp.cadence > 0) {
                    xml += `                <ns3:RunCadence>${Math.round(tp.cadence)}</ns3:RunCadence>\n`;
                }
                if (tp.power && tp.power > 0) {
                    xml += `                <ns3:Watts>${Math.round(tp.power)}</ns3:Watts>\n`;
                }
                xml += `              </ns3:TPX>\n`;
                xml += `            </Extensions>\n`;
            }

            xml += `          </Trackpoint>\n`;
        }
        return xml;
    }

    function downloadTCX(workout, filename = null) {
        const tcxContent = generateTCX(workout);
        if (!filename) {
            const date = workout.startTime;
            filename = `assault-runner-${date.toISOString().split('T')[0]}_${date.toTimeString().split(' ')[0].replace(/:/g, '-')}.tcx`;
        }
        const blob = new Blob([tcxContent], { type: 'application/vnd.garmin.tcx+xml' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url; link.download = filename;
        document.body.appendChild(link); link.click(); document.body.removeChild(link);
        setTimeout(() => URL.revokeObjectURL(url), 1000);
        return { success: true, filename, size: blob.size };
    }

    function validateWorkout(workout) {
        const errors = [];
        if (!workout) { errors.push('No workout data provided'); return { valid: false, errors }; }
        if (!workout.trackpoints || workout.trackpoints.length === 0) errors.push('No trackpoints recorded');
        if (workout.durationSeconds < 10) errors.push('Workout duration too short');
        if (workout.distanceMeters < 1) errors.push('No distance recorded');
        return { valid: errors.length === 0, errors };
    }

    function getExportSummary(workout) {
        if (!workout) return null;
        const validation = validateWorkout(workout);
        return {
            duration: workout.durationFormatted, distance: `${workout.distanceMiles} mi`,
            pace: `${workout.avgPace} min/mi`, calories: `${workout.calories} kcal`,
            dataPoints: workout.dataPoints,
            heartRate: workout.avgHeartRate ? `${workout.avgHeartRate} bpm avg` : 'Not recorded',
            power: workout.avgPower ? `${workout.avgPower} watts avg` : 'Not recorded',
            isValid: validation.valid, errors: validation.errors
        };
    }

    return { generateTCX, downloadTCX, validateWorkout, getExportSummary };
})();

/**
 * Assault Runner Connect - Main Application
 */
(function() {
    'use strict';

    const elements = {
        connectBtn: document.getElementById('connectBtn'),
        disconnectBtn: document.getElementById('disconnectBtn'),
        statusIndicator: document.getElementById('statusIndicator'),
        statusText: document.getElementById('statusText'),
        deviceName: document.getElementById('deviceName'),
        compatibilityWarning: document.getElementById('compatibilityWarning'),
        speedValue: document.getElementById('speedValue'),
        paceValue: document.getElementById('paceValue'),
        distanceValue: document.getElementById('distanceValue'),
        timeValue: document.getElementById('timeValue'),
        caloriesValue: document.getElementById('caloriesValue'),
        heartRateValue: document.getElementById('heartRateValue'),
        powerValue: document.getElementById('powerValue'),
        avgSpeedValue: document.getElementById('avgSpeedValue'),
        recentPaceValue: document.getElementById('recentPaceValue'),
        startRecordingBtn: document.getElementById('startRecordingBtn'),
        stopRecordingBtn: document.getElementById('stopRecordingBtn'),
        recordingIndicator: document.getElementById('recordingIndicator'),
        recordingText: document.getElementById('recordingText'),
        recordingTime: document.getElementById('recordingTime'),
        exportPanel: document.getElementById('exportPanel'),
        downloadTcxBtn: document.getElementById('downloadTcxBtn'),
        clearDataBtn: document.getElementById('clearDataBtn'),
        summaryDuration: document.getElementById('summaryDuration'),
        summaryDistance: document.getElementById('summaryDistance'),
        summaryPace: document.getElementById('summaryPace'),
        summaryCalories: document.getElementById('summaryCalories'),
        summaryDataPoints: document.getElementById('summaryDataPoints'),
        dataLogToggle: document.getElementById('dataLogToggle'),
        dataLogContent: document.getElementById('dataLogContent'),
        logEntries: document.getElementById('logEntries'),
        logCount: document.getElementById('logCount'),
        clearLogBtn: document.getElementById('clearLogBtn')
    };

    let state = { isConnected: false, isRecording: false, recordingTimer: null, logEntries: [] };

    function init() {
        console.log('Assault Runner Connect initializing...');
        if (!BluetoothManager.isSupported()) { showCompatibilityWarning(); return; }
        setupEventListeners();
        setupCallbacks();
        console.log('Application initialized');
    }

    function showCompatibilityWarning() {
        elements.compatibilityWarning.style.display = 'flex';
        elements.connectBtn.disabled = true;
        elements.connectBtn.textContent = 'Bluetooth Not Supported';
    }

    function setupEventListeners() {
        elements.connectBtn.addEventListener('click', handleConnect);
        elements.disconnectBtn.addEventListener('click', handleDisconnect);
        elements.startRecordingBtn.addEventListener('click', handleStartRecording);
        elements.stopRecordingBtn.addEventListener('click', handleStopRecording);
        elements.downloadTcxBtn.addEventListener('click', handleDownloadTCX);
        elements.clearDataBtn.addEventListener('click', handleClearData);
        elements.dataLogToggle.addEventListener('click', toggleDataLog);
        elements.clearLogBtn.addEventListener('click', clearLog);
    }

    function setupCallbacks() {
        BluetoothManager.setConnectionChangeCallback(handleConnectionChange);
        BluetoothManager.setDataCallback(handleBluetoothData);
        BluetoothManager.setErrorCallback(handleError);
        MetricsManager.setMetricsUpdateCallback(handleMetricsUpdate);
        MetricsManager.setRecordingDataCallback(handleRecordingData);
    }

    async function handleConnect() {
        elements.connectBtn.disabled = true;
        elements.connectBtn.textContent = 'Connecting...';
        try {
            await BluetoothManager.connect();
        } catch (error) {
            handleError(error);
            elements.connectBtn.disabled = false;
            elements.connectBtn.innerHTML = `<svg class="btn-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M14.24 12.01l2.32 2.32c.28-.72.44-1.51.44-2.33 0-.82-.16-1.59-.43-2.31l-2.33 2.32zm5.29-5.3l-1.26 1.26c.63 1.21.98 2.57.98 4.02s-.36 2.82-.98 4.02l1.2 1.2c.97-1.54 1.54-3.36 1.54-5.31-.01-1.89-.55-3.67-1.48-5.19zm-3.82 1L10 2H9v7.59L4.41 5 3 6.41 8.59 12 3 17.59 4.41 19 9 14.41V22h1l5.71-5.71-4.3-4.29 4.3-4.29zM11 5.83l1.88 1.88L11 9.59V5.83zm1.88 10.46L11 18.17v-3.76l1.88 1.88z"/></svg> Connect to Assault Runner`;
        }
    }

    async function handleDisconnect() {
        if (state.isRecording) handleStopRecording();
        await BluetoothManager.disconnect();
    }

    function handleConnectionChange(event) {
        const { state: connectionState, deviceName } = event;
        switch (connectionState) {
            case 'connecting':
                elements.statusIndicator.className = 'status-indicator connecting';
                elements.statusText.textContent = 'Connecting...';
                break;
            case 'connected':
                state.isConnected = true;
                elements.statusIndicator.className = 'status-indicator connected';
                elements.statusText.textContent = 'Connected';
                elements.deviceName.textContent = deviceName || 'Unknown Device';
                elements.connectBtn.style.display = 'none';
                elements.disconnectBtn.disabled = false;
                elements.disconnectBtn.style.display = 'inline-flex';
                elements.startRecordingBtn.disabled = false;
                MetricsManager.resetMetrics();
                updateMetricsDisplay(MetricsManager.getCurrentMetrics());
                addLogEntry('Connected to ' + deviceName);
                break;
            case 'disconnected':
                state.isConnected = false;
                elements.statusIndicator.className = 'status-indicator';
                elements.statusText.textContent = 'Disconnected';
                elements.deviceName.textContent = 'No device connected';
                elements.connectBtn.style.display = 'inline-flex';
                elements.connectBtn.disabled = false;
                elements.connectBtn.innerHTML = `<svg class="btn-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M14.24 12.01l2.32 2.32c.28-.72.44-1.51.44-2.33 0-.82-.16-1.59-.43-2.31l-2.33 2.32zm5.29-5.3l-1.26 1.26c.63 1.21.98 2.57.98 4.02s-.36 2.82-.98 4.02l1.2 1.2c.97-1.54 1.54-3.36 1.54-5.31-.01-1.89-.55-3.67-1.48-5.19zm-3.82 1L10 2H9v7.59L4.41 5 3 6.41 8.59 12 3 17.59 4.41 19 9 14.41V22h1l5.71-5.71-4.3-4.29 4.3-4.29zM11 5.83l1.88 1.88L11 9.59V5.83zm1.88 10.46L11 18.17v-3.76l1.88 1.88z"/></svg> Connect to Assault Runner`;
                elements.disconnectBtn.style.display = 'none';
                elements.startRecordingBtn.disabled = true;
                addLogEntry('Disconnected');
                break;
        }
    }

    function handleBluetoothData(data) { MetricsManager.processData(data); }
    function handleMetricsUpdate(metrics) { updateMetricsDisplay(metrics); }

    function updateMetricsDisplay(metrics) {
        elements.speedValue.textContent = metrics.speed;
        elements.paceValue.textContent = metrics.pace;
        elements.distanceValue.textContent = metrics.distance;
        elements.timeValue.textContent = metrics.time;
        elements.caloriesValue.textContent = metrics.calories;
        elements.avgSpeedValue.textContent = metrics.avgSpeed;
        elements.recentPaceValue.textContent = metrics.recentPace;
        elements.heartRateValue.textContent = metrics.heartRate || '--';
        elements.powerValue.textContent = metrics.power || '--';
    }

    function handleStartRecording() {
        if (!state.isConnected) return;
        MetricsManager.startRecording();
        state.isRecording = true;
        elements.startRecordingBtn.style.display = 'none';
        elements.stopRecordingBtn.style.display = 'inline-flex';
        elements.stopRecordingBtn.disabled = false;
        elements.recordingIndicator.classList.add('recording');
        elements.recordingText.textContent = 'Recording';
        updateRecordingTime();
        state.recordingTimer = setInterval(updateRecordingTime, 1000);
        elements.exportPanel.style.display = 'none';
        addLogEntry('Recording started');
    }

    function handleStopRecording() {
        const workout = MetricsManager.stopRecording();
        state.isRecording = false;
        if (state.recordingTimer) { clearInterval(state.recordingTimer); state.recordingTimer = null; }
        elements.startRecordingBtn.style.display = 'inline-flex';
        elements.startRecordingBtn.disabled = !state.isConnected;
        elements.stopRecordingBtn.style.display = 'none';
        elements.recordingIndicator.classList.remove('recording');
        elements.recordingText.textContent = 'Not Recording';
        elements.recordingTime.textContent = '';
        if (workout && workout.dataPoints > 0) showExportPanel(workout);
        addLogEntry('Recording stopped');
    }

    function updateRecordingTime() {
        const status = MetricsManager.getRecordingStatus();
        if (status.isRecording) elements.recordingTime.textContent = MetricsManager.formatTime(status.duration);
    }

    function showExportPanel(workout) {
        const summary = ExportManager.getExportSummary(workout);
        elements.summaryDuration.textContent = summary.duration;
        elements.summaryDistance.textContent = summary.distance;
        elements.summaryPace.textContent = summary.pace;
        elements.summaryCalories.textContent = summary.calories;
        elements.summaryDataPoints.textContent = summary.dataPoints;
        elements.exportPanel.style.display = 'block';
        elements.downloadTcxBtn.disabled = !summary.isValid;
    }

    function handleDownloadTCX() {
        const workout = MetricsManager.getRecordedWorkout();
        if (!workout) { alert('No workout data to export'); return; }
        try {
            const result = ExportManager.downloadTCX(workout);
            addLogEntry(`Exported: ${result.filename}`);
        } catch (error) { handleError(error); }
    }

    function handleClearData() {
        if (confirm('Clear all recorded workout data?')) {
            MetricsManager.clearRecordedData();
            elements.exportPanel.style.display = 'none';
            addLogEntry('Workout data cleared');
        }
    }

    function handleRecordingData(dataPoint) {
        if (dataPoint.elapsedSeconds % 5 === 0) {
            const logText = `${MetricsManager.formatTime(dataPoint.elapsedSeconds)} | ${dataPoint.speedMph.toFixed(1)} mph | ${dataPoint.distanceMiles.toFixed(2)} mi` + (dataPoint.heartRate ? ` | ${Math.round(dataPoint.heartRate)} bpm` : '');
            addLogEntry(logText, false);
        }
    }

    function handleError(error) {
        console.error('Error:', error);
        addLogEntry(`Error: ${error.message}`);
        alert(error.message || 'An unexpected error occurred');
    }

    function toggleDataLog() {
        const isVisible = elements.dataLogContent.style.display !== 'none';
        elements.dataLogContent.style.display = isVisible ? 'none' : 'block';
        elements.dataLogToggle.querySelector('.collapse-icon').classList.toggle('expanded', !isVisible);
    }

    function addLogEntry(message, isEvent = true) {
        state.logEntries.push({ timestamp: new Date().toLocaleTimeString(), message, isEvent });
        if (state.logEntries.length > 100) state.logEntries.shift();
        renderLog();
    }

    function renderLog() {
        if (state.logEntries.length === 0) {
            elements.logEntries.innerHTML = '<p class="log-empty">No data recorded yet. Connect to your Assault Runner and start recording.</p>';
        } else {
            elements.logEntries.innerHTML = state.logEntries.slice().reverse().map(entry => `<div class="log-entry"><span class="log-timestamp">${entry.timestamp}</span><span class="log-data">${entry.message}</span></div>`).join('');
        }
        elements.logCount.textContent = `${state.logEntries.length} entries`;
    }

    function clearLog() { state.logEntries = []; renderLog(); }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
})();
    </script>
</body>
</html>
